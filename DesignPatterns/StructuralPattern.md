# 적응자(ADAPTER)

## 의도
클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응시킵니다. 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킵니다. 

## 다른 이름
래퍼(Wapper)

## 활용성
- 기존 클래스를 사용하고 싶은데 인터페이스가 맞지 않을 때
- 아직 예측하지 못한 클래스나 실제 관련되지 않는 클래스들이 기존 클래스를 재사용하고자 하지만, 이미 정의된 재사용 가능한 클래스가 지금 요청하는 인터페이스를 꼭 정의하고 있지 않을 때. 다시 말해, 이미 만든 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없을 때
- 이미 존재하는 여러 개의 서브클래스를 사용해야 하는데, 이 서브클래스들의 상속을 통해서 이들의 인터페이스를 다 개조한다는 것이 현실성이 없을 때. 객체 적응자를 써서 부모 클래스의 인터페이스를 변형하는 것이 더 바람직함. - 객체 적응자만 해당됨 -

## 참여자 
- Target : 사용자가 사용할 응용 분야에 종속적인 인터페이스를 정의하는 클래스로서, Shape을 예로 들 수 있습니다. 
- Client : Target 인터페이스를 만족하는 객체와 동작할 대상으로 DrawingEditor를 예로 들 수 있습니다. 
- Adaptee : 인터페이스의 적응이 필요한 기존 인터페이스를 정의하는 클래스로서, 적응대상자라고 합니다. TextView가 예가 될 수 있습니다. 
- Adapter : Target 인터페이스에 Adaptee의 인터페이스를 적응시키는 클래스입니다. 

## 결과
- Adapter 클래스는 Adaptee 클래스를 Target 클래스로 변형하는데, 이를 위해 Adaptee 클래스를 상속받아야 하기 때문에, 하나의 클래스와 이 클래스의 모든 서브클래스들을 개조할 때라면 클래스 적응자 방식을 사용할 수 없습니다. 즉, Adapter는 명시적으로 Adaptee를 상속받고 있을 뿐 Adaptee의 서브클래스들을 상속받는 것은 아니므로, Adaptee의 서브클래스에 정의된 기능들을 사용할 수 없습니다. 
- Adapter 클래스는 Adaptee 클래스를 상속하기 때문에 Adaptee에 정의된행동을 재정의할 수도 있습니다. 
- 한 개의 객체만 사용하면, Adaptee로 가기 위한 추가적인 포인터 간접화는 필요하지 않다. 

# 가교(BRIDGE)

## 의도
구현에서 추상을 분리하여, 이들이 독립적으로 다양성을 가질 수 있도록 합니다. 

## 다른이름
핸들/구현부(Handle/Body)

## 활용성
- 추상적 개념과 이에 대한 구현 사이의 지속적인 종속 관계를 피하고 싶을 때
- 추상적 개념과 구현 모두가 독립적으로 서브클래싱을 통해 확장되어야 할 때

## 참여자 
- Abstraction : 추상적 개념에 대한 인터페이스를 제공하고 객체 구현자에 대한 참조자를 관리합니다. 
- RefinedAbstraction : 추상적 개념에 정의된 인터페이스를 확장합니다. 
- Implementor : 구현 클래스에 해단 인터페이스를 제공합니다. 
- ConcreteImplementor : Implementor 인터페이스를 구현하는 것으로 실제적인 구현 내용을 담았습니다. 

## 결과
1. 인터페이스와 구현 분리
2. 확장성 제고
3. 구현 세부 사항을 사용자에게서 숨기기

# 복합체(COMPOSITE)

## 의도
부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성합니다. 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴입니다. 

## 활용성
- 부분-전체의 객체 계통을 표현하고 싶을 때
- 사용자가 객체의 합성으로 생긴 복합 객체와 개개의 객체 사이의 차이를 알지 않고도 자기 일을 할 수 있도록 만들고 싶을 때. 사용자는 복합 구조의 모든 객체를 똑같이 취급하게 됩니다. 

## 참여자
- Component : 집합 관계에 정의될 모든 객체에 대한 인터페이스를 정의합니다. 모든 클래스에 해당하는 인터페이스에 대해서는 공통의 행동을 구현합니다. 전체 클래스에 속한 요소들을 관리하는 데 필요한 인터페이스를 정의합니다. 순환 구조에서 요소들을 포함하는 전체 클래스로 접근하는 데 필요한 인터페이스를 정의하며, 적절하다면 그 인터페이스를 구현합니다. 
- Leaf : 가장 말단의 객체, 즉 자식이 없는 객체를 나타냅니다. 객체 합성에 가장 기본이 되는 객체의 행동을 정의합니다. 
- Composite : 자식이 있는 구성요소에 대한 행동을 정의합니다. 자신이 복합하는 요소들을 저장하면서, Component 인터페이스에 정의된 자식 관련 연산을 구현합니다. 
- Client : Component 인터페이스를 통해 복합 구조 내의 객체들을 조작합니다. 

## 결과 
- 기본 객체와 복합 객체로 구성된 하나의 일관된 클래스 계통을 정의합니다. 기본 객체는 더 복합적인 객체들에 속해있을 수 있습니다. 물론 이 복합 객체 역시 다른 것에 속해있는 것일 수 있습니다. 그러나 사용자 코드는 일반화된 상위 개념의 객체를 조작하는 방식으로 프로그래밍하면, 런타임 기본 객체와 복합 객체를 구분하지 않고 일관되게 프로그래밍할 수 있게 됩니다. 
- 사용자의 코드가 단순해집니다. 사용자 코드는 복합 구조이나 단일 객체와 동일하게 다루는 코드로 작성되기 때문입니다. 즉, 사용자는 객체의 특성이 복합 구조인지 단일 구조인지조차 모르고 개발할 수 있습니다. 이런 구분이 필요치 않으므로 개발자의 코드에 "꼬리표-case-문장" 스타일의 함수를 쓸 필요가 없어지므로 코드가 단순해집니다. 
- 새로운 종류의 구성요소를 쉽게 추가할 수 있습니다. 새롭게 정의된 Composite 나 Leaf의 서브클래스들은 기존에 존재하는 구조들과 독립적으로 동작이 가능하게 됩니다. 그러므로 새로운 요소가 추가되었다고 해서 사용자의 프로그램이 변경될 필요는 전혀 없습니다. 
- 설계가 지나치게 범용성을 많이 가집니다. 새로운 요소를 쉽게 추가할 때의 단점은 복합체의 구성요소에 제약을 가하기 힘들다는 것입니다. 가끔 복합체가 오직 한 개의 구성요소만 가졌으면 할 때가 있습니다. Composite 클래스만으로 타입 시스템을 통해 이런 제약을 가할 수 없습니다. 런타임 점검이 들어가야 합니다. 
